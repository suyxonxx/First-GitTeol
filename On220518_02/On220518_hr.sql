/*
    집합 연산자 : UNION, UNION ALL, MINUS, INTERSECT
    UNION, UNION ALL : 합집합 처리. UNION은 중복 제거 O, UNION ALL은 중복 제거 X
    MINUS : 먼저 작성한 SELECT문의 결과값에서 다음 SELECT문의 결과 값을 차집합 처리
    INTERSECT : 교집합 처리.
 */
SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID <= 100
UNION
SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID >= 60;

SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID <= 100
MINUS
SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID >= 50;

SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID <= 100
INTERSECT
SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID >= 50;

--JOBS 테이블에서 JOB_TITLE 기준으로 정렬하여 직업 조회
SELECT *
FROM JOBS
ORDER BY  JOB_TITLE;

--CONTRIES 테이블에서 COUNTRY_NAME 기준 내림차순으로 정렬하여 조회
SELECT *
FROM COUNTRIES
ORDER BY COUNTRY_NAME DESC;

--EMPLOYEES 테이블에서 SALARY가 10000에서 12000 사이인 직원 조회
SELECT *
FROM EMPLOYEES
WHERE SALARY >= 10000 AND SALARY <= 12000;

SELECT *
FROM EMPLOYEES
WHERE SALARY BETWEEN 10000 AND 12000;

--EMPLOYEE 테이블에서 JOB_ID가 'IF' FRPG와 'ST_MAN'인 직원 조회
SELECT *
FROM EMPLOYEES
WHERE JOB_ID = 'IT_PROG' OR JOB_ID = 'ST_MAN';

SELECT *
FROM EMPLOYEES
WHERE JOB_ID IN('IT_PROG', 'ST_MAN');

--EMPLOYEES 테이블에서 MANAGE_ID가 NULL인 직원 조회
SELECT *
FROM EMPLOYEES
WHERE MANAGER_ID IS NULL;

--DEPARTMENTS 테이블에서 MANAGER_ID가 NULL이 아닌 부서 조회
SELECT *
FROM DEPARTMENTS
WHERE MANAGER_ID IS NOT NULL;

--EMPLOYEES 테이블에서 JOB_ID가 'AD'로 시작하는 직원 조회
SELECT *
FROM EMPLOYEES
WHERE JOB_ID LIKE 'AD%';

--EMPLOYEES 테이블의 FIRST_NAME에서 'ni'를 포함하는 직원 조회
SELECT *
FROM EMPLOYEES
WHERE FIRST_NAME LIKE '%ni%';

/*
    LOWER : 모든 문자들을 소문자로 출력
    UPPER : 모든 문자들을 대문자로 출력
    INITCAP : 첫 문자는 대문자, 나머지 문자들을 소문자로 출력
 */
SELECT FIRST_NAME, LOWER(FIRST_NAME), UPPER(FIRST_NAME),INITCAP(FIRST_NAME)
FROM EMPLOYEES;

--SUBSTR : 문자열 일부 추출
SELECT JOB_ID, SUBSTR(JOB_ID, 1, 2) AS STR1, SUBSTR(JOB_ID, 4)
FROM EMPLOYEES;

--REPLACE : 문자열 찾아 바꾸기
SELECT JOB_ID, REPLACE(JOB_ID, 'MGR', 'MANAGER')
FROM EMPLOYEES;

SELECT JOB_ID, REPLACE(JOB_ID, 'PROG', 'PROGRAMMER')
FROM EMPLOYEES;

--CONCAT : 문자열 이어붙이기
SELECT FIRST_NAME, LAST_NAME,
CONCAT(FIRST_NAME, CONCAT(' ', LAST_NAME)) AS FULL_NAME
FROM EMPLOYEES;

--LENGTH : 문자열의 길이값을 반환.
SELECT FIRST_NAME, LENGTH(FIRST_NAME)
FROM EMPLOYEES;

--INSTR : 찾는 문자열의 위치값을 반환. 해당 문자열이 없으면 0을 반환함.
SELECT FIRST_NAME, INSTR(FIRST_NAME, 'a')
FROM EMPLOYEES;

--LPAD, RPAD : 문자열의 빈공간을 채움으로써 길이를 통일시킴.
SELECT LPAD(FIRST_NAME, 10, '*'), RPAD(FIRST_NAME, 10, '*')
FROM EMPLOYEES;

--LTRIM은 왼쪽에서, RTRIM은 오른쪽에서 특정 문자열을 제거
SELECT JOB_ID, LTRIM(JOB_ID, 'A'), RTRIM(JOB_ID, 'T')
FROM EMPLOYEES;

--TRIM : 양옆의 공백 제거
SELECT TRIM('   홍길동       '), TRIM('     어사 박문수         ')
FROM DUAL;

SELECT LENGTH(TRIM('   홍길동       ')), LENGTH(TRIM('     어사 박문수         '))
FROM DUAL;

--JOBS 테이블에서 JOB_TITLE과 소문자와 대문자로 변환한 JOB_TITLE을 조회
SELECT JOB_TITLE, LOWER(JOB_TITLE), UPPER(JOB_TITLE)
FROM JOBS;

--EMPLOYEE 테이블에서 FIRST_NAME 첫 1 문자와 LAST_NAME 조회
SELECT SUBSTR(FIRST_NAME, 1, 1), LAST_NAME
FROM EMPLOYEES;

--EMPLOYEES 테이블에서 JOB_ID가 'REP'인 부분을 'REPRESENTATIVE'로 바꿔서 조회
SELECT JOB_ID, REPLACE(JOB_ID, 'REP', 'REPRESENTATIVE') --이 문제는 다시 볼 것.
FROM EMPLOYEES;

/*  EMPLOYEES 테이블에서 FIRST_NAME 첫 1 문자와 LAST_NAME을 중간에 공백을 두고
    하나로 결합하여 조회*/
SELECT SUBSTR(FIRST_NAME, 1, 1), LAST_NAME,
CONCAT (SUBSTR(FIRST_NAME, 1, 1), CONCAT(' ', LAST_NAME))
FROM EMPLOYEES;

--EMPLOYEES 테이블에서 FIRST_NAME과 LAST_NAME의 길이를 합쳐서 조회
SELECT CONCAT(FIRST_NAME, LAST_NAME), LENGTH(CONCAT(FIRST_NAME, LAST_NAME))
FROM EMPLOYEES;

--EMPLOYEES 테이블에서 JOB_ID와 JOB_ID에서 'A' 문자의 위치 조회
SELECT JOB_ID, INSTR(JOB_ID, 'A')
FROM EMPLOYEES;

--LOCATIONS 테이블의 CITY를 15자리 문자열로 바꾸고, 빈 공간을 '.'로 표현하여 조회
SELECT CITY, LPAD(CITY, 15, '.'), RPAD(CITY, 15, '.')
FROM LOCATIONS;

/*  LOCATIONS 테이블에서 CITY의 왼쪽부터 'S' 문자를 지운 것과
    오른쪽부터 'e' 문자를 지운 결과를 조회*/
SELECT CITY, LTRIM(CITY, 'S'), RTRIM(CITY, 'e')
FROM LOCATIONS;

/*  <숫자 함수>
    CEIL : 정수 올림,  FLOOR : 정수 내림,
    ROUND : 반올림,  TRUNC : 절삭
    MOD : 나머지,  POWER : 거듭제곱,  SQRT : 제곱근
    SIGN : 양수이면 1, 음수이면 -1, 0은 그대로 반환
 */
SELECT CEIL(12.345), FLOOR(12.345),
ROUND(12.345, 0), ROUND(1234.567, -3), TRUNC(12.345, 1),
MOD(12, 5), POWER(3, 3), SQRT(9),
SIGN(10), SIGN(0), SIGN(-5)
FROM DUAL;

SELECT SYSDATE, SYSDATE + 1, SYSDATE + 100
FROM DUAL;

SELECT * FROM EMPLOYEES;

SELECT SYSDATE, MONTHS_BETWEEN(SYSDATE, HIRE_DATE)
FROM EMPLOYEES
WHERE EMPLOYEE_ID = 100;

SELECT SYSDATE, ROUND(MONTHS_BETWEEN(SYSDATE, HIRE_DATE), 0)
FROM EMPLOYEES
WHERE EMPLOYEE_ID = 100;

SELECT HIRE_DATE, ADD_MONTHS(HIRE_DATE, 2), ADD_MONTHS(HIRE_DATE, -2)
FROM EMPLOYEES;

/*
    TO_CHAR : 숫자나 날짜 데이터를 문자 데이터로 변환
    TO_NUMBER : 문자 데이터를 숫자 데이터로 변환
    TO_DATE : 문자 데이터를 날짜 데이터로 변환
    
    CC : 세기, AD : 서기, Q : 분기
    D : 두자리로 맞춤 X, DD : 두자리로 맞춤 O
    DDD : 해당 년도의 1월 1일부터 현재까지 지난 일수
 */
SELECT TO_CHAR(SYSDATE, 'CC AD Q')
FROM DUAL;

SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD')
FROM DUAL;

SELECT TO_CHAR(SYSDATE, 'YYYY-MON-DDD')
FROM DUAL;

--  9 → 자릿수 맞춤 X, 0 → 자릿수 맞춤 O
SELECT SALARY, TO_CHAR(SALARY, '$9,999,999')
FROM EMPLOYEES;

SELECT SALARY, TO_CHAR(SALARY, '$0,000,000')
FROM EMPLOYEES;
